use std::path::Path;
use std::fs;
use tauri::Window as TauriWindow;
use sha2::{Sha256, Digest};
use std::io::Read;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MalwareFile {
    pub path: String,
    pub threat_level: String, // "low", "medium", "high", "critical"
    pub threat_type: String,  // "trojan", "virus", "adware", "pup", "autostart", "suspicious_script"
    pub reason: String,
    pub size: u64,
    pub hash: Option<String>, // SHA256 hash
    pub is_autostart: bool,
}

/// Patterns de fichiers malveillants courants
const MALWARE_PATTERNS: &[(&str, &str, &str)] = &[
    // (pattern, threat_type, threat_level)
    // Fichiers exécutables suspects
    (".exe", "suspicious_executable", "medium"),
    (".scr", "screensaver_malware", "high"),
    (".vbs", "script_malware", "high"),
    (".js", "script_malware", "medium"),
    (".bat", "batch_malware", "medium"),
    (".cmd", "batch_malware", "medium"),
    (".ps1", "powershell_malware", "high"),
    
    // Fichiers cachés suspects
    ("desktop.ini", "hidden_malware", "medium"),
    ("thumbs.db", "suspicious_system", "low"),
];

/// Répertoires suspects
const SUSPICIOUS_DIRS: &[&str] = &[
    "AppData/Local/Temp",
    "AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup",
    ".config/autostart",
    "/tmp",
    "/var/tmp",
];

/// Noms de fichiers malveillants courants
const MALWARE_NAMES: &[(&str, &str, &str)] = &[
    // (filename_pattern, threat_type, threat_level)
    ("svchost", "trojan", "critical"),
    ("lsass", "trojan", "critical"),
    ("explorer", "trojan", "high"),
    ("winlogon", "trojan", "high"),
    ("rundll32", "trojan", "high"),
    ("regsvcs", "trojan", "high"),
    ("msiexec", "trojan", "high"),
    ("userinit", "trojan", "high"),
    ("wscript", "trojan", "high"),
    ("cscript", "trojan", "high"),
    ("powershell", "trojan", "high"),
    ("cmd", "trojan", "high"),
    ("bitcoin", "adware", "medium"),
    ("miner", "adware", "medium"),
    ("crypto", "adware", "medium"),
];

pub async fn scan_for_malware(root_path: &str, limit: u32) -> Result<Vec<MalwareFile>, String> {
    let mut malware_files = Vec::new();
    let mut scanned = 0u32;

    // Augmenter la limite interne pour un scan très profond
    let internal_limit = (limit * 20).max(1000);
    
    scan_directory(root_path, &mut malware_files, &mut scanned, internal_limit, 0)?;

    // Trier par niveau de menace
    malware_files.sort_by(|a, b| {
        let threat_order = |level: &str| match level {
            "critical" => 0,
            "high" => 1,
            "medium" => 2,
            "low" => 3,
            _ => 4,
        };
        threat_order(&a.threat_level).cmp(&threat_order(&b.threat_level))
    });

    Ok(malware_files.into_iter().take(limit as usize).collect())
}

pub async fn scan_for_malware_with_progress(window: TauriWindow, root_path: &str, limit: u32) -> Result<Vec<MalwareFile>, String> {
    let mut malware_files = Vec::new();
    let mut scanned = 0u32;

    // Augmenter la limite interne pour un scan très profond
    let internal_limit = (limit * 20).max(1000);
    
    scan_directory_with_progress(&window, root_path, &mut malware_files, &mut scanned, internal_limit, 0)?;

    // Trier par niveau de menace
    malware_files.sort_by(|a, b| {
        let threat_order = |level: &str| match level {
            "critical" => 0,
            "high" => 1,
            "medium" => 2,
            "low" => 3,
            _ => 4,
        };
        threat_order(&a.threat_level).cmp(&threat_order(&b.threat_level))
    });

    Ok(malware_files.into_iter().take(limit as usize).collect())
}

pub async fn scan_autostart_entries() -> Result<Vec<MalwareFile>, String> {
    let mut autostart_files = Vec::new();

    #[cfg(target_os = "macos")]
    {
        // LaunchAgents et LaunchDaemons
        let autostart_dirs = vec![
            "/Library/LaunchAgents",
            "/Library/LaunchDaemons",
            "/System/Library/LaunchAgents",
            "/System/Library/LaunchDaemons",
        ];

        for dir in autostart_dirs {
            if let Ok(entries) = fs::read_dir(dir) {
                for entry in entries.flatten() {
                    if let Ok(metadata) = entry.metadata() {
                        if metadata.is_file() {
                            let path_str = entry.path().display().to_string();
                            if path_str.ends_with(".plist") {
                                autostart_files.push(MalwareFile {
                                    path: path_str.clone(),
                                    threat_level: "medium".to_string(),
                                    threat_type: "autostart".to_string(),
                                    reason: "Launch agent/daemon - runs at startup".to_string(),
                                    size: metadata.len(),
                                    hash: calculate_file_hash(&path_str),
                                    is_autostart: true,
                                });
                            }
                        }
                    }
                }
            }
        }
    }

    #[cfg(target_os = "windows")]
    {
        // Windows startup folders and registry
        let startup_dirs = vec![
            "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup",
            "C:\\Users\\Public\\Start Menu\\Programs\\Startup",
        ];

        for dir in startup_dirs {
            if let Ok(entries) = fs::read_dir(dir) {
                for entry in entries.flatten() {
                    if let Ok(metadata) = entry.metadata() {
                        let path_str = entry.path().display().to_string();
                        autostart_files.push(MalwareFile {
                            path: path_str.clone(),
                            threat_level: "medium".to_string(),
                            threat_type: "autostart".to_string(),
                            reason: "Startup program".to_string(),
                            size: metadata.len(),
                            hash: calculate_file_hash(&path_str),
                            is_autostart: true,
                        });
                    }
                }
            }
        }
    }

    Ok(autostart_files)
}

fn calculate_file_hash(path: &str) -> Option<String> {
    if let Ok(mut file) = fs::File::open(path) {
        let mut hasher = Sha256::new();
        let mut buffer = Vec::new();
        
        // Limiter la lecture à 10MB pour éviter les gros fichiers
        if file.read_to_end(&mut buffer).is_ok() && buffer.len() < 10 * 1024 * 1024 {
            hasher.update(&buffer);
            let result = hasher.finalize();
            return Some(format!("{:x}", result));
        }
    }
    None
}

fn scan_directory(
    path: &str,
    malware_files: &mut Vec<MalwareFile>,
    scanned: &mut u32,
    limit: u32,
    depth: u32,
) -> Result<(), String> {
    if malware_files.len() >= limit as usize {
        return Ok(());
    }

    // Limiter la profondeur à 8 niveaux
    if depth > 8 {
        return Ok(());
    }

    match fs::read_dir(path) {
        Ok(entries) => {
            for entry in entries.flatten() {
                if malware_files.len() >= limit as usize {
                    break;
                }

                *scanned += 1;

                if let Ok(metadata) = entry.metadata() {
                    let path_str = entry.path().display().to_string();

                    if metadata.is_file() {
                        if let Some(malware) = check_file_for_malware(&path_str, &metadata) {
                            malware_files.push(malware);
                        }
                    } else if metadata.is_dir() && *scanned < 50000 {
                        // Augmenter la limite de fichiers scannés
                        let _ = scan_directory(&path_str, malware_files, scanned, limit, depth + 1);
                    }
                }
            }
        }
        Err(_) => {
            // Ignorer les erreurs d'accès
        }
    }

    Ok(())
}

fn check_file_for_malware(path: &str, metadata: &fs::Metadata) -> Option<MalwareFile> {
    let path_obj = Path::new(path);
    let file_name = path_obj.file_name()?.to_str()?.to_lowercase();
    let file_stem = path_obj.file_stem()?.to_str()?.to_lowercase();

    // Vérifier les noms de fichiers suspects
    for (pattern, threat_type, threat_level) in MALWARE_NAMES {
        if file_stem.contains(pattern) && !is_system_file(path) {
            // Vérifier que ce n'est pas un fichier système légitime
            if is_suspicious_malware_name(&file_stem, pattern) {
                return Some(MalwareFile {
                    path: path.to_string(),
                    threat_level: threat_level.to_string(),
                    threat_type: threat_type.to_string(),
                    reason: format!("Suspicious filename pattern: {}", pattern),
                    size: metadata.len(),
                    hash: calculate_file_hash(path),
                    is_autostart: false,
                });
            }
        }
    }

    // Vérifier les extensions
    if let Some(ext) = path_obj.extension() {
        let ext_str = ext.to_str()?.to_lowercase();
        let ext_with_dot = format!(".{}", ext_str);

        for (pattern, threat_type, threat_level) in MALWARE_PATTERNS {
            if ext_with_dot.ends_with(pattern) {
                // Vérifier si c'est dans un répertoire suspect
                if is_in_suspicious_directory(path) {
                    return Some(MalwareFile {
                        path: path.to_string(),
                        threat_level: threat_level.to_string(),
                        threat_type: threat_type.to_string(),
                        reason: format!("Suspicious file in suspicious directory: {}", pattern),
                        size: metadata.len(),
                        hash: calculate_file_hash(path),
                        is_autostart: false,
                    });
                }
            }
        }
    }

    // Vérifier les fichiers cachés suspects
    if file_name.starts_with('.') || file_name.starts_with('~') {
        for (pattern, threat_type, threat_level) in MALWARE_PATTERNS {
            if file_name.contains(pattern) {
                return Some(MalwareFile {
                    path: path.to_string(),
                    threat_level: threat_level.to_string(),
                    threat_type: threat_type.to_string(),
                    reason: format!("Hidden suspicious file: {}", pattern),
                    size: metadata.len(),
                    hash: calculate_file_hash(path),
                    is_autostart: false,
                });
            }
        }
    }

    None
}

fn is_system_file(path: &str) -> bool {
    let path_lower = path.to_lowercase();
    
    // Répertoires système Windows
    if path_lower.contains("system32")
        || path_lower.contains("syswow64")
        || path_lower.contains("windows/system") {
        return true;
    }
    
    // Répertoires système Unix/Linux/macOS
    if path_lower.contains("usr/bin")
        || path_lower.contains("usr/sbin")
        || path_lower.contains("usr/lib") {
        return true;
    }
    
    // Répertoires d'extensions d'éditeurs (VS Code, Windsurf, etc.)
    if path_lower.contains(".vscode/extensions")
        || path_lower.contains(".trae/extensions")
        || path_lower.contains(".windsurf/extensions")
        || path_lower.contains("/.config/extensions") {
        return true;
    }
    
    // Répertoires de packages/dépendances
    if path_lower.contains("node_modules")
        || path_lower.contains("site-packages")
        || path_lower.contains("dist-packages")
        || path_lower.contains(".cargo")
        || path_lower.contains(".gem")
        || path_lower.contains(".m2") {
        return true;
    }
    
    // Répertoires de type stubs Python
    if path_lower.contains("typeshed")
        || path_lower.contains("jedi/third_party") {
        return true;
    }
    
    false
}

fn is_suspicious_malware_name(file_stem: &str, pattern: &str) -> bool {
    // Noms de fichiers système sûrs qui contiennent les patterns
    let safe_names = vec![
        "cmd.pyi",      // Python type stub
        "cmd.py",       // Python module
        "powershell.pyi", // Python type stub
        "bash",         // Shell
        "sh",           // Shell
    ];
    
    // Vérifier si c'est un fichier système sûr
    if safe_names.contains(&file_stem) {
        return false;
    }
    
    // Éviter les faux positifs pour les fichiers système
    if file_stem == pattern {
        return true;
    }

    // Vérifier si c'est une variante suspecte
    if file_stem.starts_with(pattern) {
        let suffix = &file_stem[pattern.len()..];
        // Accepter les variantes avec des chiffres ou caractères spéciaux
        !suffix.chars().all(|c| c.is_alphanumeric())
    } else {
        false
    }
}

fn is_in_suspicious_directory(path: &str) -> bool {
    let path_lower = path.to_lowercase();
    SUSPICIOUS_DIRS.iter().any(|dir| path_lower.contains(&dir.to_lowercase()))
}

fn scan_directory_with_progress(
    window: &TauriWindow,
    path: &str,
    malware_files: &mut Vec<MalwareFile>,
    scanned: &mut u32,
    limit: u32,
    depth: u32,
) -> Result<(), String> {
    if malware_files.len() >= limit as usize {
        return Ok(());
    }

    // Limiter la profondeur à 15 niveaux pour un scan très profond
    if depth > 15 {
        return Ok(());
    }

    match fs::read_dir(path) {
        Ok(entries) => {
            for entry in entries.flatten() {
                if malware_files.len() >= limit as usize {
                    break;
                }

                *scanned += 1;

                // Émettre la progression tous les 100 fichiers
                if *scanned % 100 == 0 {
                    let _ = window.emit("malware-scan-progress", serde_json::json!({
                        "filesScanned": *scanned,
                        "threatsFound": malware_files.len(),
                    }));
                }

                if let Ok(metadata) = entry.metadata() {
                    let path_str = entry.path().display().to_string();

                    if metadata.is_file() {
                        if let Some(malware) = check_file_for_malware(&path_str, &metadata) {
                            malware_files.push(malware);
                        }
                    } else if metadata.is_dir() && *scanned < 100000 {
                        // Augmenter la limite de fichiers scannés pour un scan très profond
                        let _ = scan_directory_with_progress(window, &path_str, malware_files, scanned, limit, depth + 1);
                    }
                }
            }
        }
        Err(_) => {
            // Ignorer les erreurs d'accès
        }
    }

    Ok(())
}
